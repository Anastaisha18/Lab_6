# Вавилина Настя ИТ-7 Лабораторная №6

# Задание 1.1

### Текст задачи 
@Invoke.  
Разработайте аннотацию @Invoke, со следующими характеристиками:  
• Целью может быть только МЕТОД  
• Доступна во время исполнения программы  
• Не имеет свойств  
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них  
аннотацией @Invoke.  
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные  
аннотацией @Invoke, и вызывает их автоматически.  


### Алгоритм решения
1. Создать аннотацию @Invoke:
- @Target(ElementType.METHOD) - только для методов  
- @Retention(RetentionPolicy.RUNTIME) - доступна во время выполнения  
- Без свойств
2. Создать класс-пример с методами:  
- Пометить несколько методов @Invoke  
- Оставить один метод без аннотации  
3. Создать обработчик processInvoke(Object obj):  
- Получить класс объекта: obj.getClass()  
- Получить все методы: getDeclaredMethods()  
- Для каждого метода проверить: isAnnotationPresent(Invoke.class)  
- Если есть аннотация:  
  - setAccessible(true) - для доступа к private методам
  - invoke(obj) - вызвать метод  

### Тест



# Задание 1.2

@Default.
Разработайте аннотацию @Default, со следующими характеристиками:  
• Целью может быть ТИП или ПОЛЕ  
• Доступна во время исполнения программы  
• Имеет обязательное свойство value типа Class  
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.  
Напишите обработчик, который выводит имя указанного класса по умолчанию.  

### Алгоритм решения
1. Создать аннотацию @Default:  
- @Target({ElementType.TYPE, ElementType.FIELD}) - для класса и поля  
- @Retention(RetentionPolicy.RUNTIME)  
- Свойство: Class<?> value() - обязательное
2. Создать класс-пример:  
- Повесить @Default(String.class) на класс  
- Повесить @Default(Integer.class) на поле  
3. Создать обработчик processDefault(Class<?> clazz):  
- Проверить аннотацию на классе: isAnnotationPresent(Default.class)  
- Получить значение: getAnnotation(Default.class).value()  
- Получить все поля: getDeclaredFields()  
- Для каждого поля проверить наличие аннотации  
- Вывести имена классов: getSimpleName()  

### Тест



# Задание 1.3

### Текст задачи
@ToString.  
Разработайте аннотацию @ToString, со следующими характеристиками:  
• Целью может быть ТИП или ПОЛЕ  
• Доступна во время исполнения программы  
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO  
• Значение свойства по умолчанию: YES  
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).  
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,  
где @ToString имеет значение YES.  

### Алгоритм решения
1. Создать аннотацию @ToString:  
- @Target({ElementType.TYPE, ElementType.FIELD})  
- @Retention(RetentionPolicy.RUNTIME)  
- Создать enum Mode {YES, NO}  
- Свойство: Mode value() default Mode.YES  
2. Создать класс-пример:  
- @ToString на классе  
- Поле с @ToString (YES)  
- Поле с @ToString(Mode.NO)  
- Поле без аннотации  
3. Создать обработчик processToString(Object obj):  
- Получить класс и его поля  
- Проверить аннотацию на классе (для полей без аннотации)  
- Для каждого поля:  
  - Если есть аннотация на поле: использовать её значение  
  - Если нет: использовать значение с класса  
- Собрать строку: ClassName{field1=value1, field2=value2}  

### Тест



# Задание 1.4

### Текст задачи
@Validate.  
Разработайте аннотацию @Validate, со следующими характеристиками:  
• Целью может быть ТИП или АННОТАЦИЯ  
• Доступна во время исполнения программы  
• Имеет обязательное свойство value, типа Class[]  
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.  
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.  

### Алгоритм решения
1. Создать аннотацию @Validate:  
- @Target({ElementType.TYPE, ElementType.ANNOTATION_TYPE})  
- @Retention(RetentionPolicy.RUNTIME)  
- Свойство: Class<?>[] value() - обязательное  
2. Создать класс-пример:  
- @Validate({String.class, Integer.class, Double.class, Boolean.class})  
3. Создать обработчик processValidate(Class<?> clazz):  
- Проверить наличие аннотации  
- Получить массив классов: getAnnotation(Validate.class).value()  
- Перебрать массив и вывести имена: getSimpleName()  

### Тест




# Задание 1.5

### Текст задачи
@Two.  
Разработайте аннотацию @Two, со следующими характеристиками:  
• Целью может быть ТИП  
• Доступна во время исполнения программы  
• Имеет два обязательных свойства: first типа String и second типа int  
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.  
Реализуйте обработчик, который считывает и выводит значения этих свойств.  

### Алгоритм решения
1. Создать аннотацию @Two:  
- @Target(ElementType.TYPE)  
- @Retention(RetentionPolicy.RUNTIME)  
- Свойства: String first() и int second() - оба обязательные  
2. Создать класс-пример:  
@Two(first = "Hello", second = 100)  
3. Создать обработчик processTwo(Class<?> clazz):  
- Проверить наличие аннотации  
- Получить аннотацию: getAnnotation(Two.class)  
- Вывести: first() и second()  

### Тест



# Задание 1.6

### Текст задачи
@Cache.  
Разработайте аннотацию @Cache, со следующими характеристиками:  
• Целью может быть ТИП  
• Доступна во время исполнения программы  
• Имеет необязательное свойство value, типа String[]  
• Значение свойства по умолчанию: пустой массив  
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.  
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что  
список пуст.  

### Алгоритм решения
1. Создать аннотацию @Cache:  
- @Target(ElementType.TYPE)  
- @Retention(RetentionPolicy.RUNTIME)  
- Свойство: String[] value() default {} - необязательное  
2. Создать классы-примеры:  
- @Cache({"users", "products", "orders"}) - с данными  
- @Cache - пустой массив  
3. Создать обработчик processCache(Class<?> clazz):  
- Проверить наличие аннотации  
- Получить массив: getAnnotation(Cache.class).value()  
- Если длина 0: вывести "Список пуст"  
- Иначе: перебрать и вывести все элементы  
### Тест




# Задание 2.3

### Текст задачи 
Разработайте тест, используя фреймворк JUnit, который проверяет корректность обработки  
аннотации @Default.  
• Проверить, что значение свойства value совпадает с ожидаемым классом.  
• Убедиться, что если аннотация установлена на класс или поле, то отражение (Reflection)  
корректно возвращает её экземпляр.  
• Добавить параметризованный тест (@ParameterizedTest) для проверки нескольких  
классов с разными типами по умолчанию  

### Алгоритм тестирования аннотаций
1. Проверка значения value:  
- Получить аннотацию с класса DefaultEx  
- Сравнить value() с String.class  
- Получить аннотацию с поля data  
- Сравнить value() с Integer.class  
2. Проверка Reflection:  
- Убедиться, что аннотация на классе ≠ null  
- Убедиться, что аннотация на поле ≠ null  
- Проверить, что объект аннотации instanceof Default  
3. Параметризованный тест:  
- Для 5 классов проверить @Default value():  
DefaultEx → String  
TestStringClass → String  
TestIntegerClass → Integer  
TestDoubleClass → Double  
TestBooleanClass → Boolean

### Тест



# Задание 2.5

### Текст задачи 
Реализовать тест, используя фреймворк JUnit, для класса, использующего аннотацию @Cache.  
• Проверить, что список кешируемых сущностей (value) корректно считывается.  
• Реализовать мок-тест (с использованием Mockito или встроенных подстановок),  
имитирующий обращение к кешу.  
• Проверить, что если массив пуст – кеширование не производится.  
• Добавить отдельный тест для случая, когда кеш содержит несколько именованных  
областей.  

### Алгоритм тестирования аннотаций
1. Проверка считывания value:  
- Получить аннотацию с CacheEx  
- Проверить массив = ["users","products","orders"]  
2. Мок-тест (Mockito):  
- Создать мок CacheService  
- Настроить поведение (when → thenReturn)  
- Проверить вызовы (verify)  
3. Проверка пустого массива:  
- Получить аннотацию с EmptyCacheEx  
- Проверить value().length = 0  
4. Проверка нескольких областей:  
Проверить наличие "users", "products", "orders" в массиве  

### Тест
