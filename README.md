# Вавилина Настя ИТ-7 Лабораторная №6

# Задание 1.1

### Текст задачи 
@Invoke.  
Разработайте аннотацию @Invoke, со следующими характеристиками:  
• Целью может быть только МЕТОД  
• Доступна во время исполнения программы  
• Не имеет свойств  
Создайте класс, содержащий несколько методов, и проаннотируйте хотя бы один из них  
аннотацией @Invoke.  
Реализуйте обработчик (через Reflection API), который находит методы, отмеченные  
аннотацией @Invoke, и вызывает их автоматически.  


### Алгоритм решения
1. Создать аннотацию @Invoke:
- @Target(ElementType.METHOD) - только для методов  
- @Retention(RetentionPolicy.RUNTIME) - доступна во время выполнения  
- Без свойств  
2. Создать класс-пример с методами:  
- Пометить несколько методов @Invoke  
- Оставить один метод без аннотации  
3. Создать обработчик processInvoke(Object obj):  
- Получить класс объекта: obj.getClass()  
- Получить все методы: getDeclaredMethods()  
- Для каждого метода проверить: isAnnotationPresent(Invoke.class)  
- Если есть аннотация:  
  - setAccessible(true) - для доступа к private методам
  - invoke(obj) - вызвать метод  

### Тест



# Задание 1.2

@Default.
Разработайте аннотацию @Default, со следующими характеристиками:  
• Целью может быть ТИП или ПОЛЕ  
• Доступна во время исполнения программы  
• Имеет обязательное свойство value типа Class  
Проаннотируйте какой-либо класс данной аннотацией, указав тип по умолчанию.  
Напишите обработчик, который выводит имя указанного класса по умолчанию.  

### Алгоритм решения
1. Создать аннотацию @Default:  
- @Target({ElementType.TYPE, ElementType.FIELD}) - для класса и поля  
- @Retention(RetentionPolicy.RUNTIME)  
- Свойство: Class<?> value() - обязательное  
2 .Создать класс-пример:  
- Повесить @Default(String.class) на класс  
- Повесить @Default(Integer.class) на поле  
3. Создать обработчик processDefault(Class<?> clazz):  
- Проверить аннотацию на классе: isAnnotationPresent(Default.class)  
- Получить значение: getAnnotation(Default.class).value()  
- Получить все поля: getDeclaredFields()  
- Для каждого поля проверить наличие аннотации  
- Вывести имена классов: getSimpleName()  

### Тест



# Задание 1.3

### Текст задачи
@ToString.  
Разработайте аннотацию @ToString, со следующими характеристиками:  
• Целью может быть ТИП или ПОЛЕ  
• Доступна во время исполнения программы  
• Имеет необязательное свойство valuec двумя вариантами значений: YES или NO  
• Значение свойства по умолчанию: YES  
Проаннотируйте класс аннотацией @ToString, а одно из полей – с @ToString(Mode.NO).  
Создайте метод, который формирует строковое представление объекта, учитывая только те поля,  
где @ToString имеет значение YES.  

### Алгоритм решения
1. Создать аннотацию @ToString:  
- @Target({ElementType.TYPE, ElementType.FIELD})  
- @Retention(RetentionPolicy.RUNTIME)  
- Создать enum Mode {YES, NO}  
- Свойство: Mode value() default Mode.YES  
2. Создать класс-пример:  
- @ToString на классе  
- Поле с @ToString (YES)  
- Поле с @ToString(Mode.NO)  
- Поле без аннотации  
3. Создать обработчик processToString(Object obj):
- Получить класс и его поля
- Проверить аннотацию на классе (для полей без аннотации)
- Для каждого поля:
  - Если есть аннотация на поле: использовать её значение
	- Если нет: использовать значение с класса
- Собрать строку: ClassName{field1=value1, field2=value2}

### Тест



# Задание 1.4

### Текст задачи
@Validate.  
Разработайте аннотацию @Validate, со следующими характеристиками:  
• Целью может быть ТИП или АННОТАЦИЯ  
• Доступна во время исполнения программы  
• Имеет обязательное свойство value, типа Class[]  
Проаннотируйте класс аннотацией @Validate, передав список типов для проверки.  
Реализуйте обработчик, который выводит, какие классы указаны в аннотации.  

### Алгоритм решения

### Тест




# Задание 1.5

### Текст задачи
@Two.  
Разработайте аннотацию @Two, со следующими характеристиками:  
• Целью может быть ТИП  
• Доступна во время исполнения программы  
• Имеет два обязательных свойства: first типа String и second типа int  
Проаннотируйте какой-либо класс аннотацией @Two, передав строковое и числовое значения.  
Реализуйте обработчик, который считывает и выводит значения этих свойств.  

### Алгоритм решения

### Тест



# Задание 1.6

### Текст задачи
@Cache.  
Разработайте аннотацию @Cache, со следующими характеристиками:  
• Целью может быть ТИП  
• Доступна во время исполнения программы  
• Имеет необязательное свойство value, типа String[]  
• Значение свойства по умолчанию: пустой массив  
Проаннотируйте класс аннотацией @Cache, указав несколько кешируемых областей.  
Создайте обработчик, который выводит список всех кешируемых областей или сообщение, что  
список пуст.  

### Алгоритм решения

### Тест




# Задание 2.3

### Текст задачи 
Разработайте тест, используя фреймворк JUnit, который проверяет корректность обработки  
аннотации @Default.  
• Проверить, что значение свойства value совпадает с ожидаемым классом.  
• Убедиться, что если аннотация установлена на класс или поле, то отражение (Reflection)  
корректно возвращает её экземпляр.  
• Добавить параметризованный тест (@ParameterizedTest) для проверки нескольких  
классов с разными типами по умолчанию  

### Алгоритм решения

### Тест


# Задание 2.5

### Текст задачи 
Реализовать тест, используя фреймворк JUnit, для класса, использующего аннотацию @Cache.  
• Проверить, что список кешируемых сущностей (value) корректно считывается.  
• Реализовать мок-тест (с использованием Mockito или встроенных подстановок),  
имитирующий обращение к кешу.  
• Проверить, что если массив пуст – кеширование не производится.  
• Добавить отдельный тест для случая, когда кеш содержит несколько именованных  
областей.  

### Алгоритм решения

### Тест
